// Firestore rules — travelapp (full)
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ---- helpers ----
    function isSignedIn() { return request.auth != null; }
    function changedOnly(allowed) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowed);
    }
    function stablePostFieldsUnchanged() {
      return request.resource.data.id == resource.data.id
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.username == resource.data.username
        && request.resource.data.imageUrl == resource.data.imageUrl
        && request.resource.data.createdAt == resource.data.createdAt;
    }
    function validOwnerPostEdit() {
      return changedOnly(['description','location','lat','lng','updatedAt'])
        && (!('description' in request.resource.data) || request.resource.data.description is string)
        && (!('location' in request.resource.data) || request.resource.data.location is string)
        && (!('lat' in request.resource.data) || request.resource.data.lat is number)
        && (!('lng' in request.resource.data) || request.resource.data.lng is number)
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp)
        && stablePostFieldsUnchanged();
    }

    // ============= USERS =============
    match /users/{uid} {
      allow read: if true;
      allow write: if isSignedIn() && request.auth.uid == uid;

      match /followers/{followerUid} {
        allow read: if true;
        allow create, delete: if isSignedIn() && request.auth.uid == followerUid;
        allow update: if false;
      }

      match /following/{followingUid} {
        allow read: if true;
        allow create, delete: if isSignedIn() && request.auth.uid == uid;
        allow update: if false;
      }
    }

    // ============= POSTS =============
    match /posts/{postId} {
      allow read: if true;
      allow create: if isSignedIn();

      allow update: if isSignedIn() && (
        (changedOnly(['commentCount']) && request.resource.data.commentCount is int)
        || (request.auth.uid == resource.data.uid && validOwnerPostEdit())
      );

      allow delete: if isSignedIn() && request.auth.uid == resource.data.uid;

      match /likes/{userId} {
        allow read: if true;
        allow create, delete: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
      }

      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn()
          && request.resource.data.userId == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.text.size() <= 2000;
        allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
        allow update: if false;
      }
    }

    // ============= CONVERSATIONS (DM) =============
match /conversations/{cid} {
  // Create: caller must be a participant; 2 kişilik liste
  allow create: if isSignedIn()
    && (request.resource.data.participants is list)
    && (request.resource.data.participants.size() == 2)
    && (request.resource.data.participants[0] is string)
    && (request.resource.data.participants[1] is string)
    && (request.auth.uid in request.resource.data.participants)
    // lastAt/lastMessage opsiyonel
    && (!('lastAt' in request.resource.data) || request.resource.data.lastAt is timestamp)
    && (!('lastMessage' in request.resource.data) || request.resource.data.lastMessage is string);

  // Read/Delete: yalnız katılımcılar
  allow read, delete: if isSignedIn()
    && (request.auth.uid in resource.data.participants);

  // Update: lastMessage/lastAt her zamanki gibi; participants yalnızca "aynı üyeler, farklı sıra" ise değişebilir
  allow update: if isSignedIn()
    && (request.auth.uid in resource.data.participants)
    && changedOnly(['lastMessage','lastAt','participants'])
    && (!('participants' in request.resource.data)
        || (
          request.resource.data.participants is list
          && resource.data.participants is list
          && request.resource.data.participants.size() == resource.data.participants.size()
          && request.resource.data.participants.hasAll(resource.data.participants)
          && resource.data.participants.hasAll(request.resource.data.participants)
        ))
    && (!('lastMessage' in request.resource.data) || request.resource.data.lastMessage is string)
    && (!('lastAt' in request.resource.data) || request.resource.data.lastAt is timestamp);

  match /messages/{mid} {
    allow read: if isSignedIn()
      && (request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants);

    allow create: if isSignedIn()
      && (request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants)
      && request.resource.data.keys().hasOnly(['fromUid','text','createdAt','readBy'])
      && request.resource.data.fromUid == request.auth.uid
      && request.resource.data.text is string
      && request.resource.data.text.size() > 0
      && request.resource.data.text.size() <= 4000
      && request.resource.data.createdAt is timestamp
      && request.resource.data.readBy is list
      && (request.auth.uid in request.resource.data.readBy);

    allow update: if isSignedIn()
      && (request.auth.uid in get(/databases/$(database)/documents/conversations/$(cid)).data.participants)
      && changedOnly(['readBy'])
      && request.resource.data.readBy is list
      && resource.data.readBy is list
      && request.resource.data.readBy.hasAll(resource.data.readBy)
      && request.resource.data.readBy.size() >= resource.data.readBy.size()
      && (request.auth.uid in request.resource.data.readBy);

    allow delete: if false;
  }
}

  }
}
